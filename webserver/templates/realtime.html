{% extends "base.html" %}

{% block title %}Real-Time Data - GMDI Platform{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css">
<style>
    /* Full-screen layout below navbar */
    html,
    body {
        height: 100vh;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    main {
        padding: 0 !important;
        margin: 0 !important;
        min-height: calc(100vh - 60px);
        position: relative;
    }

    main .container {
        max-width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
        min-height: calc(100vh - 60px);
        width: 100%;
    }

    footer {
        display: none !important;
    }

    .realtime-wrapper {
        width: 100%;
        min-height: calc(100vh - 60px);
        display: flex;
        flex-direction: column;
        position: relative;
    }

    .map-container {
        flex: 1;
        min-height: 0;
        position: relative;
        width: 100%;
    }

    #cml-map {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
    }

    .chart-container {
        height: 400px;
        flex-shrink: 0;
        position: relative;
        width: 100%;
        min-height: 200px;
        max-height: 80vh;
    }

    .resizer {
        height: 12px;
        background: #ddd;
        cursor: ns-resize;
        position: relative;
        z-index: 10;
        border-top: 2px solid #bbb;
        border-bottom: 2px solid #bbb;
        margin: -2px 0;
        transition: background-color 0.2s ease;
    }

    .resizer:hover {
        background: #aaa;
    }

    .resizer.active {
        background: #888;
    }

    .grafana-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: none;
        width: 100%;
        height: 100%;
    }
</style>
{% endblock %}

{% block content %}
<div class="realtime-wrapper">
    <div class="map-container">
        <div id="cml-map"></div>
    </div>
    <div class="resizer" id="resizer"></div>
    <div class="chart-container">
        <iframe class="grafana-container" id="grafana-panel"
            src="/grafana/d/cml-realtime/cml-real-time-data?orgId=1&var-cml_id=10001&refresh=10s&theme=light&viewPanel=2&kiosk"
            allowfullscreen></iframe>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
<script>
    let map;
    let cmlLayers = {};
    let cmlStats = {};
    let selectedCmlId = '10001';
    let currentColoringOption = 'completeness';

    // Color functions for each option
    const colorFunctions = {
        completeness: function (stat) {
            if (!stat) return '#0066cc';
            const completeness = stat.completeness_percent || 0;
            if (completeness >= 90) return '#22c55e'; // green
            if (completeness >= 70) return '#eab308'; // yellow
            if (completeness >= 50) return '#f97316'; // orange
            return '#ef4444'; // red
        },
        last_rsl: function (stat) {
            if (!stat) return '#0066cc';
            const rsl = stat.last_rsl;
            if (rsl === null) return '#808080'; // gray for missing data
            if (rsl >= -40) return '#22c55e'; // green
            if (rsl >= -45) return '#eab308'; // yellow
            if (rsl >= -50) return '#f97316'; // orange
            return '#ef4444'; // red
        },
        std_dev: function (stat) {
            if (!stat) return '#0066cc';
            const stddev = stat.stddev_last_60min;
            if (stddev === null) return '#808080'; // gray for missing data
            if (stddev <= 1) return '#22c55e'; // green (very stable)
            if (stddev <= 2) return '#eab308'; // yellow (moderate)
            if (stddev <= 3) return '#f97316'; // orange (variable)
            return '#ef4444'; // red (very unstable)
        }
    };

    function getColor(stat, option) {
        if (colorFunctions[option]) {
            return colorFunctions[option](stat);
        }
        return '#0066cc';
    }

    function buildPopupText(cmlId, stats) {
        var popupText = '<strong>CML ' + cmlId + '</strong><br>';
        if (stats) {
            popupText += 'Completeness: ' + stats.completeness_percent + '%<br>';
            popupText += 'Valid records: ' + stats.valid_records + '/' + stats.total_records + '<br>';
            if (stats.last_rsl !== null) {
                popupText += 'Last RSL: ' + stats.last_rsl + ' dBm<br>';
            }
            if (stats.stddev_last_60min !== null) {
                popupText += 'Std Dev (60min): ' + stats.stddev_last_60min + '<br>';
            }
        }
        return popupText;
    }

    function applyStatsToLine(cmlId, stats) {
        var polyline = cmlLayers[cmlId];
        if (!polyline) return;

        polyline._stats = stats;
        var color = getColor(stats, currentColoringOption);
        polyline.setStyle({ color: color });

        if (polyline.getPopup()) {
            polyline.setPopupContent(buildPopupText(cmlId, stats));
        } else {
            polyline.bindPopup(buildPopupText(cmlId, stats));
        }
    }

    // Initialize map
    function initializeMap() {
        console.log('Initializing map...');
        try {
            map = L.map('cml-map').setView([57.705, 11.97], 11);
            // Use Carto Positron - clean, minimal light basemap
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                maxZoom: 19,
                subdomains: 'abcd'
            }).addTo(map);
            console.log('Map created');

            // Add custom control for CML coloring
            var ColorControl = L.Control.extend({
                options: {
                    position: 'topright'
                },
                onAdd: function (map) {
                    var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                    container.style.backgroundColor = 'white';
                    container.style.padding = '10px';
                    container.style.fontSize = '14px';

                    var label = L.DomUtil.create('div', '', container);
                    label.innerHTML = '<strong>Color by:</strong>';
                    label.style.marginBottom = '5px';

                    var select = L.DomUtil.create('select', '', container);
                    select.id = 'coloringOption';
                    select.innerHTML = `
                        <option value="completeness" selected>Data Completeness</option>
                        <option value="last_rsl">Last RSL Value</option>
                        <option value="std_dev">RSL Std Dev (60min)</option>
                    `;

                    // Prevent map interactions when using the select
                    L.DomEvent.disableClickPropagation(container);
                    L.DomEvent.disableScrollPropagation(container);

                    return container;
                }
            });
            map.addControl(new ColorControl());

            // Start map rendering immediately
            loadCmlData();

            // Fetch stats in parallel and update colors/popups when ready
            console.log('Fetching CML stats...');
            try {
                fetch('/api/cml-stats')
                    .then(function (response) {
                        console.log('Stats response received:', response.status);
                        var el = document.getElementById('debugStats');
                        if (el) el.textContent = 'stats=status:' + response.status;
                        return response.json();
                    })
                    .then(function (stats) {
                        console.log('Received stats for ' + stats.length + ' CMLs');
                        stats.forEach(function (stat) {
                            cmlStats[stat.cml_id] = stat;
                            applyStatsToLine(stat.cml_id, stat);
                        });
                        var el2 = document.getElementById('debugStats');
                        if (el2) el2.textContent = 'stats=ok:' + stats.length;
                    })
                    .catch(function (error) {
                        console.error('Error loading stats:', error);
                        var errEl = document.getElementById('debugError');
                        if (errEl) errEl.textContent = 'lastError=stats:' + (error && error.message ? error.message : String(error));
                        var el3 = document.getElementById('debugStats');
                        if (el3) el3.textContent = 'stats=error';
                    });
            } catch (e) {
                console.error('Exception when fetching stats:', e);
                var errEl = document.getElementById('debugError');
                if (errEl) errEl.textContent = 'lastError=stats-ex:' + String(e);
            }
        } catch (e) {
            console.error('Error in initializeMap:', e);
        }

        // Add event listener for coloring option change
        var coloringSelect = document.getElementById('coloringOption');
        if (coloringSelect) {
            coloringSelect.addEventListener('change', function (e) {
                console.log('Coloring option changed to: ' + e.target.value);
                currentColoringOption = e.target.value;
                updateMapColors();
            });
        }
    }

    // Load and draw CML data
    function loadCmlData() {
        console.log('Loading CML map data...');
        try {
            fetch('/api/cml-map')
                .then(function (response) {
                    console.log('Map response received:', response.status);
                    var el = document.getElementById('debugMap');
                    if (el) el.textContent = 'mapData=status:' + response.status;
                    return response.json();
                })
                .then(function (cmls) {
                    console.log('Drawing ' + cmls.length + ' CMLs');
                    var el2 = document.getElementById('debugMap');
                    if (el2) el2.textContent = 'mapData=ok:' + cmls.length;
                    cmls.forEach(function (cml) {
                        drawCmlLine(cml);
                    });
                    console.log('Done drawing');
                })
                .catch(function (error) {
                    console.error('Error loading map data:', error);
                    var errEl = document.getElementById('debugError');
                    if (errEl) errEl.textContent = 'lastError=map:' + (error && error.message ? error.message : String(error));
                    var el3 = document.getElementById('debugMap');
                    if (el3) el3.textContent = 'mapData=error';
                });
        } catch (e) {
            console.error('Exception when loading map data:', e);
            var errEl = document.getElementById('debugError');
            if (errEl) errEl.textContent = 'lastError=map-ex:' + String(e);
        }
    }

    // Draw CML line on map with initial color
    function drawCmlLine(cml) {
        var cmlId = cml.cml_id;
        var stats = cmlStats[cmlId];
        var color = getColor(stats, currentColoringOption);

        var latlngs = [
            [cml.site_0.lat, cml.site_0.lon],
            [cml.site_1.lat, cml.site_1.lon]
        ];

        var polyline = L.polyline(latlngs, {
            color: color,
            weight: 2,
            opacity: 0.7
        });
        polyline.addTo(map);

        // Store the stats for updating
        polyline._cmlId = cmlId;
        polyline._stats = stats;

        // Create popup with stats (or placeholder until stats arrive)
        polyline.bindPopup(buildPopupText(cmlId, stats));

        // Add click handler
        polyline.on('click', function () {
            selectCml(cmlId);
        });

        // Add hover effects
        polyline.on('mouseover', function () {
            this.setStyle({ weight: 4, opacity: 1 });
        });
        polyline.on('mouseout', function () {
            this.setStyle({ weight: 2, opacity: 0.7 });
        });

        cmlLayers[cmlId] = polyline;
    }

    // Update all map line colors based on current coloring option
    function updateMapColors() {
        console.log('Updating colors for option: ' + currentColoringOption);
        for (var cmlId in cmlLayers) {
            if (cmlLayers.hasOwnProperty(cmlId)) {
                var polyline = cmlLayers[cmlId];
                var stats = polyline._stats;
                var color = getColor(stats, currentColoringOption);
                polyline.setStyle({ color: color });
            }
        }
    }

    // Select CML and update Grafana dashboard
    function selectCml(cmlId) {
        console.log('Selected CML: ' + cmlId);
        selectedCmlId = cmlId;

        var grafanaPanel = document.getElementById('grafana-panel');

        try {
            // Update iframe URL via pushState to avoid full reload
            var iframeWindow = grafanaPanel.contentWindow;
            var currentUrl = new URL(iframeWindow.location.href);
            currentUrl.searchParams.set('var-cml_id', cmlId);

            iframeWindow.history.pushState(null, '', currentUrl.toString());
            iframeWindow.dispatchEvent(new PopStateEvent('popstate', { state: null }));

            console.log('Updated CML ID via pushState');
        } catch (e) {
            // Fallback: rebuild URL with time range preservation
            console.warn('Could not access iframe, using fallback', e);

            var fromParam = null;
            var toParam = null;

            try {
                var url = new URL(grafanaPanel.src);
                fromParam = url.searchParams.get('from');
                toParam = url.searchParams.get('to');
            } catch (e2) {
                console.warn('Could not parse iframe URL', e2);
            }

            var base = '/grafana/d/cml-realtime/cml-real-time-data';
            var params = [
                'orgId=1',
                'var-cml_id=' + encodeURIComponent(cmlId),
                'refresh=10s',
                'theme=light',
                'viewPanel=2',
                'kiosk'
            ];

            if (fromParam && toParam) {
                params.push('from=' + encodeURIComponent(fromParam));
                params.push('to=' + encodeURIComponent(toParam));
            }

            grafanaPanel.src = base + '?' + params.join('&');
        }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function () {
        initializeMap();
        initializeResizer();
    });

    // Initialize resizer for adjustable dashboard height
    function initializeResizer() {
        const resizer = document.getElementById('resizer');
        const chartContainer = document.querySelector('.chart-container');
        let isResizing = false;
        let startY, startHeight;

        function startResize(e) {
            isResizing = true;
            startY = e.clientY;
            startHeight = chartContainer.offsetHeight;
            resizer.classList.add('active');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        }

        function doResize(e) {
            if (!isResizing) return;

            const deltaY = startY - e.clientY;
            const newHeight = startHeight + deltaY;
            const minHeight = 200;
            const maxHeight = window.innerHeight * 0.8;
            const constrainedHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));

            chartContainer.style.height = constrainedHeight + 'px';
        }

        function stopResize() {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        }

        // Use capture phase and window-level events for reliability
        resizer.addEventListener('mousedown', startResize, true);
        window.addEventListener('mousemove', doResize, true);
        window.addEventListener('mouseup', stopResize, true);
        window.addEventListener('mouseleave', stopResize, true);
    }
</script>
{% endblock %}